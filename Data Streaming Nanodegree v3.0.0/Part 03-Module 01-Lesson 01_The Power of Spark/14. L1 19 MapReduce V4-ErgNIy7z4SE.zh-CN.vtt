WEBVTT
Kind: captions
Language: zh-CN

00:00:06.950 --> 00:00:11.655
David 在解释大数据的概念时

00:00:11.654 --> 00:00:14.969
他提出了一种做法或者思路

00:00:14.970 --> 00:00:18.685
我们可以将大的数据分解成小份

00:00:18.684 --> 00:00:20.910
把一份份数据发给我们的同事

00:00:20.910 --> 00:00:22.850
进行并行计算

00:00:22.850 --> 00:00:24.865
然后搜集结果

00:00:24.864 --> 00:00:29.434
这个逻辑和 MapReduce 的逻辑很相似

00:00:29.434 --> 00:00:34.524
尽管这个是高级别的抽象化且是内存计算

00:00:34.524 --> 00:00:38.679
所以多了解一下其想法的来源是有用的

00:00:38.679 --> 00:00:42.378
让我们在带 4 个节点的集群上使用MapReduce 来计算

00:00:42.378 --> 00:00:47.524
去年我们平台每首歌被播放的次数

00:00:47.524 --> 00:00:50.030
因为我们公司现在已经很大了

00:00:50.030 --> 00:00:52.700
存储事件的日志数据有好几百G

00:00:52.700 --> 00:00:57.255
所以没法在一台机器上处理了

00:00:57.255 --> 00:01:01.800
在 MapReduce 的任务里 我们有三个标准步骤

00:01:01.799 --> 00:01:04.504
Map、shuffle 和 reduce

00:01:04.504 --> 00:01:08.954
假设我们把数据存在HDFS 里

00:01:08.954 --> 00:01:11.780
首先我们要把数据分成 

00:01:11.780 --> 00:01:16.210
一般商用电脑的计算能力可以处理的小块

00:01:16.209 --> 00:01:20.004
幸运的是 HDFS 会负责这部分内容

00:01:20.004 --> 00:01:23.015
我们把这些小块叫做分区

00:01:23.015 --> 00:01:27.109
在第一步里 每个 map处理器会在指定分区

00:01:27.109 --> 00:01:31.078
对每个记录做转换

00:01:31.078 --> 00:01:34.764
把记录转换成中间文件

00:01:34.765 --> 00:01:38.625
这个转换过程在这个例子中包括 5 个步骤

00:01:38.625 --> 00:01:41.275
先读取日志中的每一行数据

00:01:41.275 --> 00:01:45.675
检查这个是否是描述你的用户听歌的数据的事件

00:01:45.674 --> 00:01:49.344
然后我们检查一下时间戳是否在正确的范围内

00:01:49.344 --> 00:01:51.584
然后我们把歌名提取出来

00:01:51.584 --> 00:01:56.309
最后我们把歌名和数字 1 写成一个元组

00:01:56.310 --> 00:01:58.064
最后

00:01:58.064 --> 00:02:00.409
我们会有很多个中间文件

00:02:00.409 --> 00:02:04.344
里面是一堆由歌名和数字 1 组成的元组

00:02:04.344 --> 00:02:11.224
这类数据经常在大数据里出现 我们一般将其叫做键值对或元组

00:02:11.224 --> 00:02:13.280
即使有四台机器

00:02:13.280 --> 00:02:14.810
数据量还是太大了

00:02:14.810 --> 00:02:20.515
我们需要进行非常多的 map 处理才能把所有的记录转换完 

00:02:20.514 --> 00:02:23.103
一旦 map 的过程完毕了

00:02:23.104 --> 00:02:25.000
第二步就是 shuffle

00:02:25.000 --> 00:02:29.955
所有的来自中间文件的记录会在集群中洗牌

00:02:29.955 --> 00:02:31.895
最终 相同歌名的键值对和

00:02:31.895 --> 00:02:35.495
拥有相同关键字的键值对会被存到同一台机器中

00:02:35.495 --> 00:02:38.930
这样 当这个节点对值按关键字进行汇总时

00:02:38.930 --> 00:02:41.960
就可以确保所有相同歌曲的键值对都在一台机器里了

00:02:41.960 --> 00:02:45.900
这样就可以计算正确的最终结果了

00:02:45.900 --> 00:02:48.689
最后是 reduce 步骤

00:02:48.689 --> 00:02:51.530
拥有相同关键字的键值对里的值会被放到一起

00:02:51.530 --> 00:02:55.495
然后我们只要对每个关键字对应的1进行加总就行了

00:02:55.495 --> 00:02:59.930
最后计数结果会被写到输出文件

