WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.430
这里有个具体例子

00:00:02.430 --> 00:00:04.455
讲述使用 Python 的过程式编程带来的潜在问题

00:00:04.455 --> 00:00:06.269
这个代码会计算

00:00:06.269 --> 00:00:08.490
一首特定的歌曲播放的次数

00:00:08.490 --> 00:00:11.220
假设歌曲的日志已经被转换为 Python 列表

00:00:11.220 --> 00:00:14.429
我们先设置一个全局变量 play_count

00:00:14.429 --> 00:00:17.250
来记录歌曲播放的次数

00:00:17.250 --> 00:00:19.230
我们先将其初始化为 0

00:00:19.230 --> 00:00:23.399
然后我们使用 for 循环遍历列表中的所有歌曲

00:00:23.399 --> 00:00:28.969
如果歌曲标题是 “Despacito” 那么我们将play_count 增加一次

00:00:28.969 --> 00:00:31.329
然后我们运行最后这个流程

00:00:31.329 --> 00:00:35.359
代码会改变了play_count 的值

00:00:35.359 --> 00:00:38.630
如果再次运行相同的代码

00:00:38.630 --> 00:00:43.580
同样是 “Despacito” 的输入 但是每次都会给出不同的结果

00:00:43.579 --> 00:00:46.244
这个例子中的问题很容易找到

00:00:46.244 --> 00:00:49.669
但当你有几十台并行运行代码的机器时

00:00:49.670 --> 00:00:51.800
有时其中一台机器暂时出现故障

00:00:51.799 --> 00:00:54.004
你可能要重新计算一遍

00:00:54.005 --> 00:00:57.530
这些意想不到的副作用可能导致严重的问题

00:00:57.530 --> 00:01:00.094
这个问题来自于语言本身

00:01:00.094 --> 00:01:05.659
在 Python 中 我们把 def 之后东西叫做函数

00:01:05.659 --> 00:01:10.640
但严格来讲 这些 “ 函数 ” 是方法或过程 而不是函数

00:01:10.640 --> 00:01:12.239
为了避免困惑

00:01:12.239 --> 00:01:16.579
我们把数学里学的函数叫做纯函数

00:01:16.579 --> 00:01:19.489
为了更好地学习数学之外的函数定义

00:01:19.489 --> 00:01:21.530
下面我们看一个类比

00:01:21.530 --> 00:01:24.689
希望能让你更容易理解什么是函数式编程

